Refactoring:
    -The great unfucking: since compiler flags have been ignored for the past weeks (I still cant believe it), lots of code is getting optimized away.
        -Investigate and get codebase back to compiling and running with -O2 and -O3 enabled.

    -Investigate why booting can fail immediately after HPET init. Always in the same spot, but on random builds.
        -Which means it's likely APIC init. Its not the timer calibration as that dosnt run until later.

    -Virtual memory mapping: move to only mapping what we need, rather than identity mapping everything.
        -Current this crashes, probably due to forgetting to map something vital.
                
    -Refocus on adding features from the list below
    -Use FlatPtr more!

Required Mapped Virtual Memory:
    -Currently used pagetable
    -system-level bitmap
    -kernel binary
    -framebuffer
    -gdt/idt
    -acpi tables
    -regions marked as reserved in memory tables.
    -All device drivers should be smart enough to map themselves.

Time API:
    -Simple but unified way to get various forms of time (system uptime, real time) and the date.
    -A refactoring of the systemclock api.
    -Dont forget RDTSC exists, and is very precise once calibrated!

InterruptManager:
    -A nice system to 'claim' gsi/irq numbers for certain subsystems, and query which ones are available.

HPET:
    -Investigate what's actually going on here, PIT still seems to be active even after being disabled. HPET timers are not generating interrupts.
        -This sounds more like a rework.
    -Added HPET support to time api.

Strings (syslib):
    -Formatting functions, for converting PODs to strings, emplacing within strings, and extracting.

Memory:
    -Implement lazy allocation.
    -Stack frame allocator, allocator combinations (think main + fallback, AA talk on new cpp allocators!)
    -Ability to reserve pages, backed with a 'read only' a static page of zeros. Replace with real page only once written to.
    -Kernel-Eternal mapping: memory that'll never be freed during system runtime (all the globals), mark it as reserved into of claimed.

Logging:
    -Improve use of kernel Log()
    -Implement 2 stage logging. Log() only copies message details into a memory buffer. Actually accessing/displaying is implemented elsewhere, this should speed up Log().
    -Backing store for logging is circular queue - oldest messages get dropped once capacity is reached.

Multiprocessing:
    -Re-work sceduler. Its too complex for how simple it should be right now. 
    -Trampoline for booting APs. Synchronising multiple cores.
    -Implement processes: a single program unit (GDT/handles/virtual memory map), each with a number of threads.
    -Semaphore, mutex and spinlocks. ScopeGuard that can operate on any of the above.

Virtual File System:
    -Basic tree structure in memory, single root.
    -Easy mounting/unmounting
    -Deferring parts of tree to specific drivers, drivers communicate tree status under their jurisdiction
    -ext2 driver, FAT32 driver
    -proc/sys like parameter dump trees

Bootloader:
    -Multiboot1 formatted bootloader for direct loading in qemu, speed up dev cycles.

ACPI Extension:
    -Look into AML, whether to use lai (acpica is too intense, if very robust) or to roll my own.
    
Panic Subsystem:
    -Must be entirely self-contained, and disaster resistant. See implementation ideas in Panic.cpp file.

Userland:
    -syscall infrastructure
    -Userspace shell/kernel shell
    -Windowing system
    -Networking stack

Documentation:
    -Document class and function goals and intention as we go.
    -Any bulky documentation can be done in READMEs, and should be in obvious locations.

Drivers:
    -PCI(e)
    -QEMU gpu driver
    -Networking
    -ACHI
    -NVME

Libc port would be nice.
