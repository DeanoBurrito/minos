*Project Refactoring - First order of business*
    -Move all the global singleton objects xyz::The()->abc into a single structure (KernelInfo or something similar).
        -A single place to access them all. It probably wont change anything size wise, but I like the concept more.
    -System clock: abstract all available and unavailable timers through a generic clock interface.
        -It can provide accurate hi-res IRQs for scheduling
        -Local and global system uptime, as well as repeating timers and 1-shot timers.
    -Remove identity mapping all memory. If devices need mapped memory, we should be mapping + locking it as we need it.

--------------------------------

Strings (syslib):
    -Formatting functions, for converting PODs to strings, emplacing within strings, and extracting.
    -Go back and replace c-string strings within kernel to our new type-safe friend.

Memory:
    -Refactor page mapping/unmapping api, allowing optional flags to be set.
        -Ability to unmap pages 
        -Setting page flags when creating them, or modifying them when mapping.
    -Multiple generic allocators. Slab alloctors(8/16/32/64 byte wide versions), stack frame allocator.
    -Turn KHeap into a generic heap allocator, and rename it.
    -Ability to reserve pages, backed with a 'read only' a static page of zeros. Replace with real page only once written to.
    -Kernel-Eternal mapping: memory that'll never be freed during system runtime (all the globals), mark it as reserved into of claimed.

Logging:
    -Improve use of kernel Log()
    -Implement 2 stage logging. Log() only copies message details into a memory buffer. Actually accessing/displaying is implemented elsewhere, this should speed up Log().

Multiprocessing:
    -Trampoline for booting APs. Synchronising multiple cores.
    -Implement processes: a single program unit (GDT/handles/virtual memory map), each with a number of threads.
    -Semaphore, mutex and spinlocks. ScopeGuard that can operate on any of the above

Virtual File System:
    -Basic tree structure in memory, single root.
    -Easy mounting/unmounting
    -Deferring parts of tree to specific drivers, drivers communicate tree status under their jurisdiction
    -ext2 driver, FAT32 driver
    -proc/sys like parameter dump trees

Platform Layer:
    -A lot of kernel init/management is platform specific (arm has no idea what an APIC is, why bother searching for it).
     Perhaps delegating parts of kernel init (like setting up interrupts) to platform-specific code. Keep the core generic.
        -Maybe have a platform specific core (tightly integrated with that platform's bootloader), and keep the surrounds generic?
    -SystemClock: Wrapper around platform-specific timing devices (rtc/pit), can provide single-shot/periodic timers.

Init disk:
    -Bootloader should just kernel elf. Make a ramdisk and embed it into elf during linking stage.

Bootloader:
    -Bootloader specific stub to collecting info into BootInfo* struct.
    -Multiboot1 formatted bootloader for direct loading in qemu, speed up dev cycles.
    -BIOS based bootloader, an alternative to UEFI.

Userland:
    -syscall infrastructure
    -POSIX libc implementation
    -Userspace shell/kernel shell
    -Windowing system

Drivers:
    -QEMU gpu driver
    -Networking
    -ACHI
    -NVME
