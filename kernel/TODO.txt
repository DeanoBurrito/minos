Refactoring:
    -The great unfucking: since compiler flags have been ignored for the past weeks (I still cant believe it), lots of code is getting optimized away.
        -Investigate and get codebase back to compiling and running with -O2 and -O3 enabled.

    -Investigate why booting can fail immediately after HPET init. Always in the same spot, but on random builds.
        -Which means it's likely APIC init. Its not the timer calibration as that dosnt run until later.

    -Move build system up to its parent folder - kernel should only be responsible for itself now. It dosnt need to be aware of the rest of the system.
        -We can get rid of a lot of the hacks from the kernel makefile now.
        -Adding an extra level of makefile seems unnecessary, I'm leaning towards extracing makefile rules into a separate file.
            -something like 'build.mk', and then including that in the main makefile. Similar to overrides.

    -Virtual memory mapping: move to only mapping what we need, rather than identity mapping everything.
        -Current this crashes, probably due to forgetting to map something vital.
                
    -Refocus on adding features from the list below

Required Mapped Virtual Memory:
    -Currently used pagetable
    -system-level bitmap
    -kernel binary
    -framebuffer
    -gdt/idt
    -acpi tables
    -regions marked as reserved in memory tables.
    -All device drivers should be smart enough to map themselves.

Panic:
    -Capturing register state of a particular frame. If we're smart this can be reused for scheduling.
    -Panic has a lot of dependencies right now. Ideally it should be setup early in kernel init, and then left untouched.
    -By compiling code in a separate elf region, we can make a second copy in memory, incase kernel binary is overwritten.
        -This implementation will require extraction of a text-printing function, given a known framebuffer and no external code.
    -Potentially a good day's work here.

HPET:
    -Investigate what's actually going on here, PIT still seems to be active even after being disabled. HPET timers are not generating interrupts.

Strings (syslib):
    -Formatting functions, for converting PODs to strings, emplacing within strings, and extracting.
    -Go back and replace c-string strings within kernel to our new type-safe friend.
    -Goal: Keep core string class lightweight, move extended functionality into other headers, import as needed.

Memory:
    -Implement lazy allocation.
    -Multiple generic allocators. Slab alloctors(8/16/32/64 byte wide versions), stack frame allocator.
    -Turn KHeap into a generic heap allocator, and rename it.
    -Ability to reserve pages, backed with a 'read only' a static page of zeros. Replace with real page only once written to.
    -Kernel-Eternal mapping: memory that'll never be freed during system runtime (all the globals), mark it as reserved into of claimed.

Logging:
    -Improve use of kernel Log()
    -Implement 2 stage logging. Log() only copies message details into a memory buffer. Actually accessing/displaying is implemented elsewhere, this should speed up Log().
    -Backing store for logging is circular queue - oldest messages get dropped once capacity is reached.

Multiprocessing:
    -Re-work sceduler. Its too complex for how simple it should be right now. 
    -Trampoline for booting APs. Synchronising multiple cores.
    -Implement processes: a single program unit (GDT/handles/virtual memory map), each with a number of threads.
    -Semaphore, mutex and spinlocks. ScopeGuard that can operate on any of the above.

Virtual File System:
    -Basic tree structure in memory, single root.
    -Easy mounting/unmounting
    -Deferring parts of tree to specific drivers, drivers communicate tree status under their jurisdiction
    -ext2 driver, FAT32 driver
    -proc/sys like parameter dump trees

Bootloader:
    -Multiboot1 formatted bootloader for direct loading in qemu, speed up dev cycles.
    -BIOS based bootloader, an alternative to UEFI. 
        -Is this really necessary? There are so many MB1 capable bootloaders out there, we can write our own for a platform if needed.

Userland:
    -syscall infrastructure
    -POSIX libc implementation
    -Userspace shell/kernel shell
    -Windowing system
    -Networking stack

Drivers:
    -PCI(e)
    -QEMU gpu driver
    -Networking
    -ACHI
    -NVME
