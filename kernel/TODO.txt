Refactoring:
    -The great unfucking: since compiler flags have been ignored for the past weeks (I still cant believe it), lots of code is getting optimized away.
        -Investigate and get codebase back to compiling and running with -O2 and -O3 enabled.

    -A number of files have been left in 'most convinient' locations, rather than where they probably belong.
        -Example: x86 specific devices (APIC, HPET, PIT) are platform specific, and should be moved into that folder.
        -Example: KernelMain is also platform specific, and we should move this over there - begin moving towards to the 'specific core - general surrounds' model

    -Move build system up to its parent folder - kernel should only be responsible for itself now. It dosnt need to be aware of the rest of the system.
        -We can get rid of a lot of the hacks from the kernel makefile now.
        -More streamlined platform selection system.
            -I like the idea of being able to declare in a platform specific header: REQUIRE_PLATFORM(x86_64) or something similar.
            -Maybe look into defines that map to static_assert?

    -Virtual memory mapping: move to only mapping what we need, rather than identity mapping everything.
        -Current this crashes, probably due to forgetting to map something vital.

    -Move away from compiler specific things.
        -stdint-gcc.h instead of stdint.h is a big one. I'd like to simple define what gcc needs to compile properly, instead of using tightly bound headers.
        -__attribute__ is gcc specific, clang does support it, but i'm not a fan.
            -we could move to the c++ built in [[gnu::attribute_here]] style - that does have a similar issue though
            -Current design is leaning towards a header file with defines, with these resolving based on environment (detecting compiler)
                -__attribute__((packed)) would become MINOS_ATTRIB_PACKED
                -__attribute__((aligned(0x1234))) would become MINOS_ATTRIB_ALIGNED(0x1234)
                -this is also lacklustre in retrospect.
                
    -Refocus on adding features from the list below

HPET:
    -Investigate what's actually going on here, PIT still seems to be active even after being disabled. HPET timers are not generating interrupts.

Strings (syslib):
    -Formatting functions, for converting PODs to strings, emplacing within strings, and extracting.
    -Go back and replace c-string strings within kernel to our new type-safe friend.
    -Goal: Keep core string class lightweight, move extended functionality into other headers, import as needed.

Memory:
    -Implement lazy allocation.
    -Multiple generic allocators. Slab alloctors(8/16/32/64 byte wide versions), stack frame allocator.
    -Turn KHeap into a generic heap allocator, and rename it.
    -Ability to reserve pages, backed with a 'read only' a static page of zeros. Replace with real page only once written to.
    -Kernel-Eternal mapping: memory that'll never be freed during system runtime (all the globals), mark it as reserved into of claimed.

Logging:
    -Improve use of kernel Log()
    -Implement 2 stage logging. Log() only copies message details into a memory buffer. Actually accessing/displaying is implemented elsewhere, this should speed up Log().
    -Backing store for logging is circular queue - oldest messages get dropped once capacity is reached.

Multiprocessing:
    -Re-work sceduler. Its too complex for how simple it should be right now. 
    -Trampoline for booting APs. Synchronising multiple cores.
    -Implement processes: a single program unit (GDT/handles/virtual memory map), each with a number of threads.
    -Semaphore, mutex and spinlocks. ScopeGuard that can operate on any of the above.

Virtual File System:
    -Basic tree structure in memory, single root.
    -Easy mounting/unmounting
    -Deferring parts of tree to specific drivers, drivers communicate tree status under their jurisdiction
    -ext2 driver, FAT32 driver
    -proc/sys like parameter dump trees

Platform Core:
    -x86_64 core: tighly integrated bootloader and kernel core. Handles all the platform specific stuff, and dispatches to general code where it can.
    -Arm core: similar to x86, but for ARM platforms.
    -Generic surrounds. The rest of the kernel can be independant of cpu. 

Bootloader:
    -Bootloader specific stub to collecting info into BootInfo* struct.
    -Multiboot1 formatted bootloader for direct loading in qemu, speed up dev cycles.
    -BIOS based bootloader, an alternative to UEFI.

Userland:
    -syscall infrastructure
    -POSIX libc implementation
    -Userspace shell/kernel shell
    -Windowing system
    -Networking stack

Drivers:
    -PCI(e)
    -QEMU gpu driver
    -Networking
    -ACHI
    -NVME
